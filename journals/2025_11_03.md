- What are the key characteristics of data oriented design? #card
	- It is designed to speed up data processing
		- Can be better thought of as using databases like techniques on data
	- It requires consideration of the CPU
		- What slows it down?
		- What speeds it up?
- Where is data oriented design used? #card
	- Database engines
	- Games
	- Numerical simulations
	- Solvers
	- Lots of uniform data that needs processing
		- Where databases cannot be used
- What issues does object oriented design pose? #card
	- Mapping real world into objects is complex as many objects are needed to solve problems
	- Lot of indirection in object oriented design can lead to: #card
		- Extra CPU work
		- Objects on the heap
		- Mix between hot and cold data
		- Mixes read only and read write data and operations
- What is hot data? #card
	- Small amounts of data used over and over
- What problems does cache represent? #card
	- The cpu cannot use the ram directly:
		- Data is used only if its in a register
		- Instructions (code) is accessed only if it is in the nano op file
- What are the two main eviction schemes that CPUs use? #card
	- Least recently used
	- Least frequently used
- What eviction scheme do modern CPUs use? #card
	- A neural network that balances both
		- Speculative prefetching
	- Make sure the data is predictable
- What are the two main access patterns for data by the CPU? #card
	- Sequential
	- Random
- Why does this snippet use so much data and random access?: 
  ```java
  Integer[] array2[1*GB]; //48 GiB (after init) -> why?
  ...init all of array2
  for (var a: array2) { //random access! -> why?
  doStuff(a);
  }
  ``` 
  #card
	- Each Integer holds a reference to the data as well as the actual data stored
	- The random access is because we now need to access the data off the heap
	- How would you fix the efficiency issues of using heaped objects? #card
		- Use primitives
		- Use off-heap buffers to store contiguous data
		- Avoid per element looping
- Where is the variable in this line stored in the cpu? 
  ```java
  ObjectX a;
  ```
  #card
	- It is a local variable stored in L1 *Inside* the CPU
- Where is the variable in this line stored in the CPU? 
  ```java
  a = new ObjectX();
  ```
  #card
	- It is stored in the Heap in main memory
- In this line, what does the variable a represent?
  ```java
  a = new ObjectX();
  ```
  #card
	- It is a pointer to the object in the Main memory
- How many lists are in the Heap? #card
	- 4
		- What are the 4 lists stored in the heap? #card
			- Tiny object
			- Small Objects
			- Medium Objects
			- Large Objects
	- How is space on the heap allocated? #card
		- First come first serve
	- How are objects on the heap destroyed? #card
		- Random times (if garbage collected)
	- Why is data on the heap randomly distributed? #card
		- Because destruction of objects on the heap is random and leaves gaps, while lead to non-contiguous data on the heap
	- Besides the actual data on the heap, how else does adding objects to the heap use space? #card
		- The management of the objects consumes data for heap bookeeping
- What are the two main problems that Objects introduce to performace? #card
	- They live in the heap
		- What are the issues with storing objects on the heap? #card
			- Non-sequential storage
			- Time increases the randomness and therefore the access time
	- Living on the Heap leads to indirection as the addresses need to be looked up
		- What indirection arises from objects living on the heap? #card
			- We need to fetch the instruction
			- We need to fetch the reference
			- We need to find the address in the vtable
			- We need to find the function in the vtable
			- The hit or miss stuff is done when trying to predict where the data is in memory
		- What issues can indirection lead to? #card
			- Constant eviction of cached data as it is constantly being replaced by parent class calls
			- Constant eviction of cached functions as they are being replaced by parent class calls
- What is cache eviction and why is it implemented? #card
	- The calls for data need to be in groups of 32 because that is more efficient on CPUs
		- This leads to the previously cached 32 being evicted even when 1 byte of data is called
	- This is done so that more data can be loaded at once than just 1 byte at a time
- What are the steps to a data oriented design? #card
	- Split program into hot and cold data
		- How do we find hot data? #card
			- Always in a loop
			- Gets called many times a second
			- Is slowed down by more objects
		- How do we find cold data? #card
			- rare execution
			- More objects would not slow down it's performance
		- What can be done if we are unsure about where hot and cold data is in the program? #card
			- Find the bottlenecks with profilers and timers
	- Analyse the data flow
		- If many object mutate the same data, it can be abstracted away
	- Find data that if mutated or flows in the same step in the program
- How does polymorphism differ for java and C++? #card
	- Java is only runtime
	- C++ is at compile time
- Besides performance, what are the other advantages of Data oriented design? #card
	- Data is in the same place and is easier to follow
- What are the 4 steps in a CPU pipeline? #card
	- Fetch
	- Decode
	- Execute
	- Write
- How does the CPU use speculation to speed up performance? #card
	- It speculatively guesses which code and data will be executed next
	- If the guess is wrong on the actual call, it rolls back the calculation before and reexecutes before writing
- What is superscalar? #card
	- A CPU design that enables out of order execution by leveraging dependency graphs
- What is a stack engine? #card
	- A component of modern CPUs that simulate stack data in the CPU registers so that they have a lower access time
- What differences to execution exist between compile checking and CPU optimisation? #card
	- CPU can see both data and instruction, which creates a more informed dependency graph
		- Neural nets can adjust as more data flows
	- Compilers only see the code statically
- What are the 5 components of defensive programming? #card
	- Const correctness
		- Describe const correctness #card
			- A technique that uses constants to prevent accidental mutations
				- This provides clear intent
				- Reduces attack surface (fewer states can mutate)
				- Enables safer optimisation
		- What are the 3 types of constants? #card
			- Methods
			- Objects
			- Parameters
	- input validation
		- What types of input validation are there? #card
			- Bounds checking
			- Object validation
			- Capacity checking
			- SQL injections
			- HTML injections
	- assertions
		- Where should assertions be used? #card
			- In dev code, not production
			- Pre and post conditions
		- Do not put functions in assertions
	- error handling
		- What are the schools of thought in error handling? #card
			- Exceptions
				- What are the overhead considerations of using exceptions for error handling? #card
					- No overhead if they aren't tripped
					- But lots when they are
				- How should exceptions be treated? #card
					- Do not propagate errors to the user
						- Error messages dont help users
					- Prevent those mistakes from happening
			- Error codes
				- What are the overhead considerations of using error codes to handle errors? #card
					- Little overhead no matter the path
			- Directly handle errors
				-
	- resource management
- What does static analysis check for? #card
	- Code smells and bugs
- How do code sanitizers work? #card
	- Instrumenting source code
	- Injecting into compiled code
- What are the 5 types of code sanitizers? #card
	- AddressSanitizer
	- MemorySanitizer
	- UndefinedBehaviourSanitizer
	- LeakSanitizers
	- ThreadSanitizers
- What is fuzzing? #card
	- Testing by feeding randomised inputs to the code
- What does fuzzing check for? #card
	- Error handling
	- See if program misbehaves
	- Security
- What is unit testing? #card
	- Testing small sections (classes or function etc.) of code and test in isolation
- What are the 6 steps of test driven development? #card
	- Write code with no implementation
	- Write tests
	- Implement for those tests to pass
	- Add more testsA
	- Add more code
	- Make the tests comprehensive
- How do you deal with unimplemented dependencies in test driven development? #card
	- Mock or dummy objects
- What are the two ways we can select test cases? #card
	- Partition testing
		- What is partition testing? #card
			- Group test cases into categories
	- Guideline testing
		- What is guideline testing? #card
			- Use known failure points to test
- What is integration testing? #card
	- Testing that various parts and components interact well
- What are the two types of integration testing? #card
	- BigBang
		- Everything at once
	- Incremental
		- Test in phases
- What are the three approaches to integration testing? #card
	- Top-down
	- Bottom-up
	- Sandwich
- What is regression testing? #card
	- Rerun all old test when new code is added
- What are the 7 types of regression testing? #card
	- Corrective regression testing
	- Retest-all
	- Selective regression
	- Progressive
	- Complete
	- Partial
	- Unit
- What is evaluated in a user acceptance test phase? #card
	- Make sure it's what the user wanted
	- Check usability and user friendliness
	- Functionality and user stories
	- Operational and maintainable
	- Alpha and beta testing
- What are the differences between user acceptance and usability? #card
	- Usibility
		- Ease of access
		- Middle of the SDLC
		- Focus on behaviour and goals
		- Can be expensive
	- Acceptance
		- Validate requirements
		- End of SDLC
		- Focus on functionality
		- Not that expensive
- What is the difference between alpha and beta testing? #card
	- Alpha
		- Super users on in house users
	- Beta
		- End users
- What are the top ten OSWAP vulnerabilities? #card
	- Problem Fix
		- A01- Broken access control (↑5) Deny by default
		- A02- Cryptographic fail (=2) Encrypt data in transit/at rest
		- A03- Injection (↓1) Safe API + IAEF: whitelist
		- A04- Insecure design (↑↑new) “Shift left”
		- A05- Security misconfiguration (↑6) Secure installation process
		- A06- Vulnerable and outdated components (↑9) Patch management + signed comp.
		- A07- Identification and authentication fail (↓2) Multifactor auth. + no backdoors
		- A08- Software and data integrity fail (↑↑new) Signed software
		- A09- Security logging and monitoring fail (↑10) Log everything + keep logs
		- A10- Server-side request forgery (↑↑new) Sanitise + whitelist
- What is meant by the shift left of dev ops? #card
	- Move testing, security and quality to early in the process
	- Decisions made before coding, in design
	- and before testing when coding
	- Implemented in unit tests
	- perform sanitary checks regularly
- What is pen testing? #card
	- Simulate attempts to breach security of the system
- What is the Agile manifesto? #card
	- Individuals and interactions over processes and tools
	- Working software over comprehensive documentation
	- Customer collaboration over contract negotiation...
	- Responding to change over following a plan.
- What are the differences between Waterfall and Agile? #card
	- Communication
		- Waterfall: easy
		- Agile: hard
	- Division of labour
		- Waterfall: Clear
		- Agile: Unclear
	- Works well for
		- Waterfall: Known problems
		- Agile: Novel development
	- Adhesion to the plan
		- Waterfall: Close
		- Agile: Not really
- How is security addressed in architecture? #card
	- Plan ahead
	- follow secure patterns
	- Security cannot be bolted on afterwards
	- Difficult to test for
	- Users don't understand security
		- often comes at the expense of usability
- What are the 12 principles of Agile? #card
	- Satisfy the customer
	- Welcome changing requirements
	- Deliver working software frequently
	- Business and development must work together
	- Support and trust team
	- Face to face
	- Working software is the main metric of progress
	- Maintain a constant pace indefinately
	- Attention to excellence and good design
	- Simplicity
	- Self-organising teams
	- Become more effective
- How are teams empowered in agile? #card
	- Project team has the sole responsibility to deliver product
	- Interference with the project team is disruptive and reduces their motivation
	- Team must do together:
		- Establish and clarify requirements
		- Prioritise them together
		- Agree on tasks
		- Estimate effort
	- Ensure buy in and commitment
	- Own challenges
- What is Pareto's law? #card
	- 80% of results come from 20% of effort
	- We don't know which 20%
- How should requirements be captured in Agile? #card
	- High level requirements
		- Just in time to develop features
		- Minimal only to enable testing and development
	- Understand enough to determine scope
	- Captured collaboratively
- What are the considerations of capturing Agile requirements? #card
	- Only do high level requirements for low probability and low cost risks
	- Just in time requirements are only for poorly understood features
	- There must also be an understanding of interaction and security
- What are user stories? #card
	- Lightweight versions of Use cases
	- A simple statement about what the user wants to do with a featureS
	- Should be understandable to everyone
- How should user stories be captured? #card
	- Focus on the who, what and why
		- Not how
	- They should be captured at the start of development
- Users are unrealiable narrators. focus on what they do, not what they say
- How do we record user stories? #card
	- Cards with 3 parts:
		- Name
		- Conversation
		- Acceptance criteria
	- Using cards for user stories forces small, manageable requirements
	- Requirements broken down into tasks <= 16 hours
	- All items are deliverables, not tasks
- What are the characteristics of Incremental design? #card
	- No top-down approach
	- The design is the same size as the system
		- you don't need to plan ahead which is useful for coding projects whos issues are not anticipatable
		- Allows for change to the plan with flexibility
	- How does incremental design contrast to traditional design? #card
		- Traditional design is rigid and expensive to change
			- Additions at the end of the product testing require an entirely new project
			- It is difficult to perfectly predict requirements at the start of the process
		- Agile development assumes changing requirements
- How does agile development relate to budgets? #card
	- Businesses expect the following from an agile team: #card
		- On time
		- On budget
	- While scope if variable, budget and timeline is not assumes as variable
	- We need to start with the highest priority deliverables first
	- Features must be fully developed to be shippable
		- Features must be 100% complete at the end of an iteration
- What is the Agile development cycles? #card
	- Analyse
	- Develop
	- Test
	- Repeat
- What are the advantages of the Agile development cycle? #card
	- Some risks (not all) are reduced
		- Some are increased
	- Increased perceived value
	- More flexibility
	- Better cost management
- What are some values of agile? #card
	- User feedback is best received from a work in progress
	- Prototypes are better than documentation
	- Effort to make the product work is wasted time
- What benefits do prototypes provide? #card
	- Using prototypes for risky solutions increases chances of success
	- They are inexpensive
- What are the two classes of prototypes? #card
	- True prototype: Understand the problem better
	- Skeleton: Intended to be built upon
- How are prototypes worked in agile? #card
	- Continuously integrate changes
	- Integrate continuously
- What are nightly builds? #card
	- Rebuilt from scratch daily
	- As many automated tests as possible
- Performance is affected by a few critical loops
- What is pair programming? #card
	- Programmers sit in pairs adn write each line together
- Advantages of pair programming #card
	- Informal review process
	- Common ownership of code
	- Collective responsibility
	- Spreads knowledge across the team
	- Motivates refactoring
- How is pair programming more productive? #card
	- Fewer false starts
	- Two sets of eyes preventing errors
	- Helps with training
	- Particularly useful for complex tasks
- Challenges of pair programming #card
	- Pace issues
	- Constant communication
	- Different skill levels
	- Power dynamics
	- Self time
	- Context switching
- What does a good code review entale? #card
	- Every change is review by one other person
- What challenges can arise from code reviewing? #card
	- Sloppy reviews
	- Over reliance on the review
	- Sunk cost
	- Time between making and fixing bugs
- #Week2MindPalace
-
-