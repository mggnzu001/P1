Ah! I see exactly what you mean — thank you for pointing that out. Every bullet inside a flash card **must also use `-`**, never `*`. Markdown bold/italic can still use `**` for formatting, but list items **cannot**.

I will regenerate your document so that:

* Flash card titles start with `-` and end with `#card`
* Every nested bullet **inside the card uses `-`** instead of `*`
* Nested bullets can be indented with 2 spaces per level

Here’s the corrected Logseq-compatible version:

---

# **Computability & Complexity — Expanded Study Notes (with Flash Cards)**

These notes walk through the material **as a continuous conceptual narrative**, but also include **granular flash cards for memorisation**.

---

# **1. Foundations of Computation**

Computability theory begins with:

> **What does it mean for a function or problem to be computable?**

Before computers, Turing answered this with the **Turing Machine (TM)**.

---

## **1.1 Turing Machines**

TM components: tape, head, states, transitions.
They capture everything modern computers compute.

### **1.1.1 Formal Structure**

* Turing machine — definition #card

  * A **Turing machine (TM)** consists of:

    * An infinite tape divided into cells
    * A tape alphabet (includes blank `◊`)
    * A tape head that reads/writes and moves L/R
    * A finite set of states (with start + halts)
    * A transition function δ: (state, symbol) → (state, symbol, direction)
  * This formalizes *algorithmic steps*

---

## **1.2 How a Turing Machine Computes**

The TM repeats:

1. Read symbol
2. Look up δ
3. Write
4. Move L/R
5. Enter next state

The machine’s entire situation = **configuration**.

* TM configuration example #card

  * Example: `1011q701111` has head after `q7`
  * If δ(q7, 0) = (q2, R), next config = `10110q21111`

---

## **1.3 Halting, Crashing, or Looping**

TMs may:

1. Halt
2. Crash
3. Loop forever

* TM halting #card

  * A machine halts only when reaching a halting state
  * Otherwise it may loop forever

---

## **1.4 Transition Diagrams**

Arcs are labelled:

* `a/b,R` – read a, write b, move R
* `a/a` – no change

These help design machines visually

---

## **1.5 TM Building Blocks**

We design TMs from “small components”: move-to-blank, shift-right, etc.

* TM modular design #card

  * To combine M1 → M2: connect M1’s halt states to M2’s start
  * Useful for multi-stage algorithms

---

## **1.6 Multi-Tape and Nondeterministic TMs**

Extensions do not change *what* is computable

* Multi-tape TM equivalence #card

  * Multi-tape TMs can be simulated by a single-tape TM with polynomial slowdown

* Nondeterministic TM equivalence #card

  * NTMs recognize exactly the same languages as DTMs

---

# **2. Describing Languages: Regular Expressions**

---

## **2.1 Regular Expressions**

Operators: concatenation, alternation `|`, Kleene star `*`

* Regex basics #card

  * Examples:

    * `(a|b)(a|b)` → all binary strings of length 2
    * `(ab)*` → ε, ab, abab,…
    * `a|a*b` → a OR any number of a’s followed by b

---

## **2.2 Why RegExps Matter**

Regular expressions describe **finite** computation; TMs describe **unbounded**

---

# **3. Computability Theory**

Central questions:

> **What *can* TMs compute?**
> **What can they *never* compute?**

---

## **3.1 Decidable vs Acceptable Languages**

* Acceptable vs Decidable #card

  * Decidable: TM halts on all inputs (accept/reject)
  * Acceptable (RE): TM halts only on members; may loop otherwise
  * Every decidable language is acceptable

---

## **3.2 Encoding TMs as Numbers**

TMs are finite → can be encoded in binary → TMs can read other TMs

* TM encoding #card

  * Assign binary codes to states, symbols, and directions
  * Concatenate to form a **Turing number**

---

## **3.3 Countability Argument**

Countably many TMs; uncountably many languages; most languages are uncomputable

* Countability #card

  * ∣TMs∣ = countable
  * ∣Languages∣ = uncountable
  * ⇒ Some languages are uncomputable

---

## **3.4 The Halting Problem**

* Halting problem #card

  * Input: TM encoding `Ti`
  * Question: Does `Mi` halt on `Ti`?
  * No TM decides this for all inputs

### Proof (sketch)

Assume a decider `H` exists
Build W that *does the opposite* of H’s prediction on its own code

* Halting proof sketch #card

  * W(W) halts iff W(W) loops → contradiction

---

## **3.5 Implications**

* General program analysis is impossible in full generality
* Undecidability proofs often use reductions

---

# **4. Complexity Theory**

Now assume a problem *is* decidable.
We ask:

> **How long does it take?**

---

## **4.1 Class P**

* Class P #card

  * P = problems solvable by deterministic TMs in **polynomial time**
  * Considered “efficient”

---

## **4.2 Class NP**

* Class NP #card

  * NP = problems verifiable in polynomial time
  * Equivalently: solvable by NTM in polynomial time

Certificates = guessed solutions that can be verified quickly

---

## **4.3 NP-Complete Problems**

* NP-complete definition #card

  * A problem X is NP-complete if:

    * X ∈ NP
    * Every NP problem reduces to X in polynomial time
  * Cook: SAT is NP-complete

---

## **4.4 Reductions**

Convert one problem into another

* Reduction HP→TSP example #card

  * Make original edges low cost; missing edges high cost
  * Hamiltonian path ⇔ low-cost TSP tour

---

## **4.5 Common NP-Complete Problems**

* SAT
* 3SAT
* Clique
* Vertex Cover
* Hamiltonian Path
* TSP (decision)
* Subset Sum

---

# **5. Algorithmic Lower Bounds**

---

## **5.1 Trivial Lower Bounds**

* Trivial lower bound #card

  * Output size alone gives a lower bound
  * Example: writing all permutations takes Ω(n!)

---

## **5.2 Adversary Methods**

* Adversary argument #card

  * Adversary answers queries to force worst-case work
  * Example: finding the max requires ≥ n−1 comparisons

---

# **6. Strategies for Hard Problems**

---

## **6.1 Backtracking**

* Backtracking #card

  * DFS with pruning (e.g., n-queens)
  * Reject partial solutions early

---

## **6.2 Branch and Bound**

* Branch and bound #card

  * Uses upper/lower bounds to prune branches
  * Example: TSP with lower-bound pruning

---

# **7. Worked TM Constructions**

---

## **7.1 Unary Increment TM**

* Unary increment TM #card

  * Steps:

    * Move right over 1’s
    * Write a new `1`
    * Return head to start

---

## **7.2 Binary Increment (Reversed)**

* Binary reversed increment TM #card

  * Algorithm:

    * Flip first 0 → 1 and stop
    * If 1 → 0, continue
    * If blank → write 1 (carry overflow)

---

# **8. Exam Strategy Notes**

* Exam strategy #card

  * Show state marker clearly in configurations
  * Use TM building blocks
  * For reductions, prove both directions
  * State polynomial bounds
  * Use self-reference carefully in undecidability proofs
